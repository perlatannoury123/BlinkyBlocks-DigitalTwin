
/**
 * @file BBbalanceCode.hpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2023-10-06                                                                     
 **/

#ifndef BBbalanceCode_H_
#define BBbalanceCode_H_

#include "robots/blinkyBlocks/blinkyBlocksSimulator.h"
#include "robots/blinkyBlocks/blinkyBlocksWorld.h"
#include "robots/blinkyBlocks/blinkyBlocksBlockCode.h"
#include "SupportPolygon.h"

static const int BUILDST_MSG_ID = 1001;
static const int ACKCENTRE_MSG_ID = 1002;
static const int FLOODSUPPORT_MSG_ID = 1003;
static const int RESTART_MSG_ID = 1004;

class CenterData {
    Vector3D sumPositions;
    uint8_t numPts;
    SupportPolygon *support=nullptr;
public:
    CenterData() : sumPositions(0.0, 0.0, 0.0), numPts(0) { support = nullptr; };
    CenterData(const CenterData&src) : sumPositions(src.sumPositions), numPts(src.numPts) {
        if (src.support!= nullptr) support= new SupportPolygon(*src.support);
    }
    CenterData(const Vector3D &pos) : sumPositions(pos), numPts(1) { support = new SupportPolygon(16); };
    ~CenterData() { delete support; }

    void reset() {
        sumPositions.set(0.0,0.0,0.0);
        numPts=0;
        if (support) support->reset();
    }

    void update(const CenterData& src) {
        sumPositions = src.sumPositions;
        numPts = src.numPts;
        delete support; // free the previous support
        support= src.support!= nullptr? new SupportPolygon(*src.support):nullptr;
    }

    void addCenter(const Vector3D &pos) {
        sumPositions += pos;
        numPts++;
    }

    void addCenter(const CenterData &cd) {
        sumPositions += cd.sumPositions;
        numPts += cd.numPts;
    }

    void addCorners(const Vector2D &v, const Vector2D &dv) {
        if (!support) support = new SupportPolygon(5);
        support->addLastVertex(v);
        support->addLastVertex(v + Vector2D(dv.x, 0));
        support->addLastVertex(v + dv);
        support->addLastVertex(v + Vector2D(0, dv.y));
    }

    Vector3D getCenter() {
        return numPts == 0 ? sumPositions : (1.0 / numPts) * sumPositions;
    }

    SupportPolygon *getSupport() {
        return support;
    }

    bool isNull() { return numPts == 0; };

    void merge(const CenterData &cd) {
        if (!cd.support) return;
        if (support == nullptr) {
            support = new SupportPolygon(*cd.support);
        } else {
            for (int i = 0; i < cd.support->N; i++) {
                support->addVertex(cd.support->tabVertices[i]);
            }
        }
    }

    bool isStable() {
        if (numPts == 0) return false;
        return support->isInside(Vector2D(sumPositions[0] / float(numPts), sumPositions[1] / float(numPts)));
    }

    CenterData& operator=(const CenterData& src) {
        sumPositions = src.sumPositions;
        numPts = src.numPts;
        delete support;
        support= src.support!= nullptr? new SupportPolygon(*src.support):nullptr;
        return *this;
    }
};

using namespace BlinkyBlocks;

class BBbalanceCode : public BlinkyBlocksBlockCode {
private:
    BlinkyBlocksBlock *module = nullptr;
    bool isLeader = false;
    P2PNetworkInterface *parent; // link to parent in spanning tree
    vector<P2PNetworkInterface *> children; // links to children in spanning tree
    uint8_t nbWaitedAnswers;
    CenterData currentCenter;
    uint8_t blinkState = 0;
    uint8_t currentStage=0;
public :
    BBbalanceCode(BlinkyBlocksBlock *host);
    ~BBbalanceCode() {};

/**
  * This function is called on startup of the blockCode, it can be used to perform initial
  *  configuration of the host or this instance of the program.
  * @note this can be thought of as the main function of the module
  */
    void startup() override;

/**
  * @brief Message handler for the message 'broadcast'
  * @param _msg Pointer to the message received by the module, requires casting
  * @param sender Connector of the module that has received the message and that is connected to the sender
  */
    void myBuildSTFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender);

/**
  * @brief Message handler for the message 'ackCentre'
  * @param _msg Pointer to the message received by the module, requires casting
  * @param sender Connector of the module that has received the message and that is connected to the sender
  */
    void myAckCentreFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender);

    /**
  * @brief Message handler for the message 'floodSupport'
  * @param _msg Pointer to the message received by the module, requires casting
  * @param sender Connector of the module that has received the message and that is connected to the sender
  */
    void myFloodSupportFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender);

    /**
  * @brief Message handler for the message 'floodSupport'
  * @param _msg Pointer to the message received by the module, requires casting
  * @param sender Connector of the module that has received the message and that is connected to the sender
  */
    void myRestartFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender);

    /**
  * @brief Callback function called when an interruption event occurs
  */
    void onInterruptionEvent(shared_ptr<Event>) override;

    /**
         * @brief Callback function called when an neighbor is added or removed
         * @param face: the connected face number
         * @param action: EVENT_ADD_NEIGHBOR or EVENT_REMOVE_NEIGHBOR
         */
    void onNeighborChanged(uint64_t face, int action) override;

    /**
  * @brief Provides the user with a pointer to the configuration file parser, which can be used to read additional user information from each block config. Has to be overridden in the child class.
  * @param config : pointer to the TiXmlElement representing the block configuration file, all information related to concerned block have already been parsed
  *
  */
    void parseUserBlockElements(TiXmlElement *config) override;

    /**
     * Call by world during GL drawing phase, can be used by a user
     *  to draw custom Gl content into the simulated world
     * @note call is made from World::GlDraw
     */
    void onGlDraw() override;

    void initCenter();

/*****************************************************************************/
/** needed to associate code to module                                      **/
    static BlockCode *buildNewBlockCode(BuildingBlock *host) {
        return (new BBbalanceCode((BlinkyBlocksBlock *) host));
    }
/*****************************************************************************/
};

#endif /* BBbalanceCode_H_ */